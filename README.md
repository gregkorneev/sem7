rm -rf build && find . -type f -name '*.png' -delete && cmake -B build && cmake --build build && cd ./build && ./app && cd .. && python3 plot_metrics_ext.py .

# Отчёт по запуску и интерпретации результатов

Ниже описано, **что именно вы получите** после запуска команды на первой строке и как интерпретировать выводы (консоль, CSV, графики).

---

## 1) Консольный вывод `./app`

В консоль печатаются сводные блоки по каждому варианту кэша:
- **LRU (iterative / recursive)** — «наименее давно использованный»
- **LFU (iterative / recursive)** — «наименее часто использованный»

В каждом блоке отображаются:
- **Capacity / Size** — ёмкость и текущий размер кэша.
- **Ops / gets / puts / evictions** — сколько операций выполнено, сколько чтений/записей, и сколько вытеснений.
- **HitRate / MissRate** — процент попаданий и промахов в кэш.
- **Average time per op (ns)** — среднее время одной операции (наносекунды).
- **Operations per second** — производительность (операций в секунду).

Также печатаются «**Speedup ratios**» — коэффициенты ускорения между вариантами (например, `Recursive/Iterative`), где значения **> 1.0** означают, что числитель **медленнее** знаменателя.

> Краткая интерпретация: выше **HitRate** и ниже **avg time** — лучше. Высокие **ops/sec** = выше производительность.

---

## 2) CSV‑файлы, которые создаёт `./app`

После выполнения `./app` в корне проекта появятся несколько CSV-файлов:

### `results_extended.csv` — общий срез по каждому варианту кэша
Колонки:
- `algo, impl, capacity` — алгоритм (LRU/LFU), реализация (iter/rec), ёмкость.
- `elapsed_ns` — суммарное время сценария (нс).
- `gets, puts, evictions` — счётчики операций.
- `hit_rate, miss_rate` — качество кэширования (%).
- `avg_ns, ops_per_sec` — среднее время на операцию, операций/сек.
- `useful_evictions, harmful_evictions, eviction_efficiency` — эффективность вытеснений (чем выше `eviction_efficiency`, тем лучше).
- `theoretical_memory, actual_memory, overhead_memory, memory_efficiency, overhead_pct` — оценка памяти: теоретическая, фактическая и накладные расходы.
- `warmup_ops` — оценка длины «прогрева» (сколько окон понадобилось до стабилизации hit rate).
- `cost_per_op` — **стоимость одной операции** (метрика №11): чем ниже, тем лучше.
- `fragmentation_ratio` — **приблизительная фрагментация памяти** в % (метрика №9).

### `scalability_extended.csv` — масштабируемость (метрика №5)
Для разных размеров кэша (`size`) записаны:
- `elapsed_ns, avg_ns, ops_per_sec` — время и производительность,
- `hit_rate` — качество кэширования,
- `useful_evictions, harmful_evictions, eviction_efficiency` — эффективность вытеснений.

> Интерпретация: по мере роста `size` обычно растёт `hit_rate` и меняется `elapsed_ns`. Это позволяет оценить тренд сложности и «цену» увеличения ёмкости.

### `stability.csv` — стабильность (метрика №13)
Несколько независимых прогонов (`trial = 0..4`) для каждой пары `algo+impl`:
- `ops_per_sec` — используйте среднее и отклонение для понимания стабильности.

### `efficiency_score.csv` — интегральная эффективность (метрика №14)
Содержит комбинированный скор с учётом hit rate, скорости и памяти:
- `score` — чем выше, тем «лучше баланс» качество/скорость/память.
- `stability_score` — вклад стабильности.

### `roi.csv` — экономическая эффективность (метрика №15)
- `roi` — условный показатель «выгодности» реализации (выше — лучше).
- `perf_score, resource, impl_cost, maint_cost` — компоненты расчёта.

### `algorithm_efficiency.csv` — эффективность алгоритма (метрика №6)
- Пропорция «полезных» операций (грубая оценка) для LRU/LFU и их реализаций.

### `warmup.csv` — данные «прогрева» (метрика №12)
- `step, hit_rate` — динамика hit rate по окнам (обычно окно = 1000 операций).

---

## 3) Графики, которые строит `plot_metrics_ext.py`

Скрипт читает CSV и сохраняет изображения в корне проекта:

1. **`scalability_time_ext.png` — Масштабируемость (Время vs размер кэша)**  
   - По оси X — `size` (ёмкость кэша), по оси Y — `elapsed_ns` (время).
   - Несколько линий: LRU/LFU и их варианты (iter/rec).  
   - **Зачем:** увидеть тренд сложности и сравнить варианты.

2. **`scalability_hit_ext.png` — Качество кэширования (Hit Rate vs размер)**  
   - По оси X — `size`, по Y — `hit_rate, %`.
   - **Зачем:** как растёт качество кэширования при увеличении ёмкости.

3. **`eviction_eff_bar.png` — Эффективность вытеснений**  
   - Столбцовая диаграмма `eviction_efficiency` для всех вариантов.
   - **Зачем:** оценить, как алгоритм справляется с «холодными»/«горячими» ключами при вытеснении.

4. **`efficiency_score.png` — Интегральная эффективность**  
   - Сравнивает общий «баланс» скорость/качество/память между реализациями.

5. **`roi_bar.png` — Экономическая эффективность**  
   - Сравнение ROI для реализаций (условная «окупаемость» решения).

6. **`warmup_graph.png` — Прогрев кэша**  
   - По X — номер окна (например, каждые 1000 операций), по Y — `hit_rate, %`.
   - **Зачем:** увидеть момент стабилизации и оценить «длину прогрева».

> Быстрая интерпретация:
> - Линия **времени** ниже = быстрее.  
> - Линия **hit rate** выше = лучше качество кэширования.  
> - Выше **eviction_efficiency** = реже вытесняются «горячие» элементы.  
> - Выше **score** и **ROI** = более «разумное» решение с учётом ограничений.

---

## 4) Что считать «хорошими» результатами

- **Hit Rate**: 80–95% — хорошо, < 50% — плохо (зависит от нагрузки и размера кэша).
- **Average time per op**: чем ниже, тем лучше (сравнивайте между вариантами).
- **Eviction efficiency**: высокий % полезных вытеснений лучше.
- **Memory efficiency**: ближе к 100% — меньше накладных расходов.
- **Warm-up**: чем короче «прогрев», тем быстрее кэш выходит на стабильный режим.
- **ROI / score**: относительные показатели — сравнивайте между вариантами.

---

## 5) Итог

После запуска вы получите полный набор **таблиц (CSV)** и **графиков**, позволяющих:
- сравнить **LRU vs LFU**,
- сравнить **итеративную vs рекурсивную** реализации,
- оценить **качество, скорость, память, стабильность, экономичность**,
- и увидеть **динамику прогрева** кэша.

Используйте графики для визуальных выводов в отчёте, а CSV — как источник фактов и численных таблиц.
